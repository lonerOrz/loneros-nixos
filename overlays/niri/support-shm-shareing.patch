From ed066764587978dc473b08afda3f18346fa2ce8b Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Sun, 31 Aug 2025 20:56:13 +0800
Subject: [PATCH 01/17] pw_utils: create a struct called DmaNegotiationResult

---
 src/pw_utils.rs | 45 +++++++++++++++++++++++++--------------------
 1 file changed, 25 insertions(+), 20 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 7cf76058d..546d02206 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -104,6 +104,12 @@ struct CastInner {
     rendering_buffers: Vec<(NonNull<pw_buffer>, SyncPoint)>,
 }

+#[derive(Debug, Clone, Copy)]
+struct DmaNegotiationResult {
+    modifier: Modifier,
+    plane_count: i32,
+}
+
 #[allow(clippy::large_enum_variant)]
 #[derive(Debug)]
 enum CastState {
@@ -113,14 +119,12 @@ enum CastState {
     ConfirmationPending {
         size: Size<u32, Physical>,
         alpha: bool,
-        modifier: Modifier,
-        plane_count: i32,
+        extra_negotiation_result: DmaNegotiationResult,
     },
     Ready {
         size: Size<u32, Physical>,
         alpha: bool,
-        modifier: Modifier,
-        plane_count: i32,
+        extra_negotiation_result: DmaNegotiationResult,
         // Lazily-initialized to keep the initialization to a single place.
         damage_tracker: Option<OutputDamageTracker>,
     },
@@ -414,8 +418,10 @@ impl PipeWire {
                         *state = CastState::ConfirmationPending {
                             size: format_size,
                             alpha: format_has_alpha,
-                            modifier,
-                            plane_count: plane_count as i32,
+                            extra_negotiation_result: DmaNegotiationResult {
+                                modifier,
+                                plane_count: plane_count as i32,
+                            },
                         };

                         let fixated_format = FormatSet::from_iter([Format {
@@ -455,22 +461,20 @@ impl PipeWire {
                         CastState::ConfirmationPending {
                             size,
                             alpha,
-                            modifier,
-                            plane_count,
+                            extra_negotiation_result,
                         }
                         | CastState::Ready {
                             size,
                             alpha,
-                            modifier,
-                            plane_count,
+                            extra_negotiation_result,
                             ..
                         } if *alpha == format_has_alpha
-                            && *modifier == Modifier::from(format.modifier()) =>
+                            && extra_negotiation_result.modifier
+                                == Modifier::from(format.modifier()) =>
                         {
                             let size = *size;
                             let alpha = *alpha;
-                            let modifier = *modifier;
-                            let plane_count = *plane_count;
+                            let extra_negotiation_result = *extra_negotiation_result;

                             let damage_tracker =
                                 if let CastState::Ready { damage_tracker, .. } = &mut *state {
@@ -484,12 +488,11 @@ impl PipeWire {
                             *state = CastState::Ready {
                                 size,
                                 alpha,
-                                modifier,
-                                plane_count,
+                                extra_negotiation_result,
                                 damage_tracker,
                             };

-                            plane_count
+                            extra_negotiation_result.plane_count
                         }
                         _ => {
                             // We're negotiating a single modifier, or alpha or modifier changed,
@@ -518,8 +521,10 @@ impl PipeWire {
                             *state = CastState::Ready {
                                 size: format_size,
                                 alpha: format_has_alpha,
-                                modifier,
-                                plane_count: plane_count as i32,
+                                extra_negotiation_result: DmaNegotiationResult {
+                                    modifier,
+                                    plane_count: plane_count as i32,
+                                },
                                 damage_tracker: None,
                             };

@@ -591,11 +596,11 @@ impl PipeWire {
                     let (size, alpha, modifier) = if let CastState::Ready {
                         size,
                         alpha,
-                        modifier,
+                        extra_negotiation_result,
                         ..
                     } = &inner.state
                     {
-                        (*size, *alpha, *modifier)
+                        (*size, *alpha, extra_negotiation_result.modifier)
                     } else {
                         trace!(stream_id, "pw stream: add buffer, but not ready yet");
                         return;

From b2447949199ed1c6812fb53a4afcd333f45efb2c Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Mon, 1 Sep 2025 16:30:43 +0800
Subject: [PATCH 02/17] pw_utils: add comments about pw negotiating

---
 src/pw_utils.rs | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 546d02206..72ebcebce 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -364,6 +364,22 @@ impl PipeWire {
                     );
                     inner.min_time_between_frames = min_frame_time;

+                    // We have following cases when param_changed:
+                    //
+                    // 1. Modifier exists and its flags contain DONT_FIXATE
+                    //
+                    //    Do test allocation, set CastState to ConfirmationPending and send param
+                    //    again.
+                    //
+                    // 2. Modifier exists and it doesn't need fixation
+                    //
+                    //    Do test allocation to ensure the modifier work, then set CastState to
+                    //    Ready. Then set buffer to DMA.
+                    //
+                    // 3. Modifier doesn't exist
+                    //
+                    //    set CastState to Ready and set buffer to SHM.
+
                     let object = pod.as_object().unwrap();
                     let Some(prop_modifier) =
                         object.find_prop(spa::utils::Id(FormatProperties::VideoModifier.0))

From 0af4c2c4ec1b7c72468ee87ae99cc2fedb989658 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Mon, 1 Sep 2025 16:42:01 +0800
Subject: [PATCH 03/17] pw_utils: refactor modifier negotiation logic

This commit is preparation for supporting shared memory sharing
---
 src/pw_utils.rs | 402 ++++++++++++++++++++++++------------------------
 1 file changed, 202 insertions(+), 200 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 72ebcebce..f2ec1d4df 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -378,229 +378,231 @@ impl PipeWire {
                     //
                     // 3. Modifier doesn't exist
                     //
-                    //    set CastState to Ready and set buffer to SHM.
+                    //    TODO: set CastState to Ready and set buffer to SHM.

                     let object = pod.as_object().unwrap();
-                    let Some(prop_modifier) =
-                        object.find_prop(spa::utils::Id(FormatProperties::VideoModifier.0))
-                    else {
-                        warn!(stream_id, "pw stream: modifier prop missing");
-                        stop_cast();
-                        return;
-                    };

-                    if prop_modifier.flags().contains(PodPropFlags::DONT_FIXATE) {
-                        debug!(stream_id, "pw stream: fixating the modifier");
+                    match object.find_prop(spa::utils::Id(FormatProperties::VideoModifier.0)) {
+                        Some(prop_modifier)
+                            if prop_modifier.flags().contains(PodPropFlags::DONT_FIXATE) => {

-                        let pod_modifier = prop_modifier.value();
-                        let Ok((_, modifiers)) = PodDeserializer::deserialize_from::<Choice<i64>>(
-                            pod_modifier.as_bytes(),
-                        ) else {
-                            warn!(stream_id, "pw stream: wrong modifier property type");
-                            stop_cast();
-                            return;
-                        };
+                                debug!(stream_id, "pw stream: fixating the modifier");

-                        let ChoiceEnum::Enum { alternatives, .. } = modifiers.1 else {
-                            warn!(stream_id, "pw stream: wrong modifier choice type");
-                            stop_cast();
-                            return;
-                        };
+                                let pod_modifier = prop_modifier.value();
+                                let Ok((_, modifiers)) = PodDeserializer::deserialize_from::<Choice<i64>>(
+                                    pod_modifier.as_bytes(),
+                                ) else {
+                                    warn!(stream_id, "pw stream: wrong modifier property type");
+                                    stop_cast();
+                                    return;
+                                };

-                        let (modifier, plane_count) = match find_preferred_modifier(
-                            &gbm,
-                            format_size,
-                            fourcc,
-                            alternatives,
-                        ) {
-                            Ok(x) => x,
-                            Err(err) => {
-                                warn!(
+                                let ChoiceEnum::Enum { alternatives, .. } = modifiers.1 else {
+                                    warn!(stream_id, "pw stream: wrong modifier choice type");
+                                    stop_cast();
+                                    return;
+                                };
+
+                                let (modifier, plane_count) = match find_preferred_modifier(
+                                    &gbm,
+                                    format_size,
+                                    fourcc,
+                                    alternatives,
+                                ) {
+                                    Ok(x) => x,
+                                    Err(err) => {
+                                        warn!(
+                                            stream_id,
+                                            "pw stream: couldn't find preferred modifier: {err:?}"
+                                        );
+                                        stop_cast();
+                                        return;
+                                    }
+                                };
+
+                                debug!(
                                     stream_id,
-                                    "pw stream: couldn't find preferred modifier: {err:?}"
+                                    "pw stream: allocation successful \
+                                    (modifier={modifier:?}, plane_count={plane_count}), \
+                                    moving to confirmation pending"
                                 );
-                                stop_cast();
-                                return;
-                            }
-                        };
-
-                        debug!(
-                            stream_id,
-                            "pw stream: allocation successful \
-                             (modifier={modifier:?}, plane_count={plane_count}), \
-                             moving to confirmation pending"
-                        );
-
-                        *state = CastState::ConfirmationPending {
-                            size: format_size,
-                            alpha: format_has_alpha,
-                            extra_negotiation_result: DmaNegotiationResult {
-                                modifier,
-                                plane_count: plane_count as i32,
-                            },
-                        };

-                        let fixated_format = FormatSet::from_iter([Format {
-                            code: fourcc,
-                            modifier,
-                        }]);
-
-                        let mut b1 = Vec::new();
-                        let mut b2 = Vec::new();
-
-                        let o1 = make_video_params(
-                            &fixated_format,
-                            format_size,
-                            inner.refresh,
-                            format_has_alpha,
-                        );
-                        let pod1 = make_pod(&mut b1, o1);
-
-                        let o2 = make_video_params(
-                            &formats,
-                            format_size,
-                            inner.refresh,
-                            format_has_alpha,
-                        );
-                        let mut params = [pod1, make_pod(&mut b2, o2)];
-
-                        if let Err(err) = stream.update_params(&mut params) {
-                            warn!(stream_id, "error updating stream params: {err:?}");
-                            stop_cast();
-                        }
+                                *state = CastState::ConfirmationPending {
+                                    size: format_size,
+                                    alpha: format_has_alpha,
+                                    extra_negotiation_result: DmaNegotiationResult {
+                                        modifier,
+                                        plane_count: plane_count as i32,
+                                    },
+                                };

-                        return;
-                    }
+                                let fixated_format = FormatSet::from_iter([Format {
+                                    code: fourcc,
+                                    modifier,
+                                }]);

-                    // Verify that alpha and modifier didn't change.
-                    let plane_count = match &*state {
-                        CastState::ConfirmationPending {
-                            size,
-                            alpha,
-                            extra_negotiation_result,
-                        }
-                        | CastState::Ready {
-                            size,
-                            alpha,
-                            extra_negotiation_result,
-                            ..
-                        } if *alpha == format_has_alpha
-                            && extra_negotiation_result.modifier
-                                == Modifier::from(format.modifier()) =>
-                        {
-                            let size = *size;
-                            let alpha = *alpha;
-                            let extra_negotiation_result = *extra_negotiation_result;
-
-                            let damage_tracker =
-                                if let CastState::Ready { damage_tracker, .. } = &mut *state {
-                                    damage_tracker.take()
-                                } else {
-                                    None
-                                };
+                                let mut b1 = Vec::new();
+                                let mut b2 = Vec::new();

-                            debug!(stream_id, "pw stream: moving to ready state");
+                                let o1 = make_video_params(
+                                    &fixated_format,
+                                    format_size,
+                                    inner.refresh,
+                                    format_has_alpha,
+                                );
+                                let pod1 = make_pod(&mut b1, o1);

-                            *state = CastState::Ready {
-                                size,
-                                alpha,
-                                extra_negotiation_result,
-                                damage_tracker,
-                            };
+                                let o2 = make_video_params(
+                                    &formats,
+                                    format_size,
+                                    inner.refresh,
+                                    format_has_alpha,
+                                );
+                                let mut params = [pod1, make_pod(&mut b2, o2)];

-                            extra_negotiation_result.plane_count
-                        }
-                        _ => {
-                            // We're negotiating a single modifier, or alpha or modifier changed,
-                            // so we need to do a test allocation.
-                            let (modifier, plane_count) = match find_preferred_modifier(
-                                &gbm,
-                                format_size,
-                                fourcc,
-                                vec![format.modifier() as i64],
-                            ) {
-                                Ok(x) => x,
-                                Err(err) => {
-                                    warn!(stream_id, "pw stream: test allocation failed: {err:?}");
+                                if let Err(err) = stream.update_params(&mut params) {
+                                    warn!(stream_id, "error updating stream params: {err:?}");
                                     stop_cast();
-                                    return;
+                                }
+                            }
+                        Some(_) => {
+                            // Verify that alpha and modifier didn't change.
+                            let plane_count = match &*state {
+                                CastState::ConfirmationPending {
+                                    size,
+                                    alpha,
+                                    extra_negotiation_result,
+                                }
+                                | CastState::Ready {
+                                    size,
+                                    alpha,
+                                    extra_negotiation_result,
+                                    ..
+                                } if *alpha == format_has_alpha
+                                && extra_negotiation_result.modifier
+                                    == Modifier::from(format.modifier()) =>
+                                {
+                                    let size = *size;
+                                    let alpha = *alpha;
+                                    let extra_negotiation_result = *extra_negotiation_result;
+
+                                    let damage_tracker =
+                                        if let CastState::Ready { damage_tracker, .. } = &mut *state {
+                                            damage_tracker.take()
+                                        } else {
+                                            None
+                                        };
+
+                                    debug!(stream_id, "pw stream: moving to ready state");
+
+                                    *state = CastState::Ready {
+                                        size,
+                                        alpha,
+                                        extra_negotiation_result,
+                                        damage_tracker,
+                                    };
+
+                                    extra_negotiation_result.plane_count
+                                }
+                                _ => {
+                                    // We're negotiating a single modifier, or alpha or modifier changed,
+                                    // so we need to do a test allocation.
+                                    let (modifier, plane_count) = match find_preferred_modifier(
+                                        &gbm,
+                                        format_size,
+                                        fourcc,
+                                        vec![format.modifier() as i64],
+                                    ) {
+                                        Ok(x) => x,
+                                        Err(err) => {
+                                            warn!(stream_id, "pw stream: test allocation failed: {err:?}");
+                                            stop_cast();
+                                            return;
+                                        }
+                                    };
+
+                                    debug!(
+                                        stream_id,
+                                        "pw stream: allocation successful \
+                                        (modifier={modifier:?}, plane_count={plane_count}), \
+                                        moving to ready"
+                                    );
+
+                                    *state = CastState::Ready {
+                                        size: format_size,
+                                        alpha: format_has_alpha,
+                                        extra_negotiation_result: DmaNegotiationResult {
+                                            modifier,
+                                            plane_count: plane_count as i32,
+                                        },
+                                        damage_tracker: None,
+                                    };
+
+                                    plane_count as i32
                                 }
                             };

-                            debug!(
-                                stream_id,
-                                "pw stream: allocation successful \
-                                 (modifier={modifier:?}, plane_count={plane_count}), \
-                                 moving to ready"
-                            );
+                            // const BPP: u32 = 4;
+                            // let stride = format.size().width * BPP;
+                            // let size = stride * format.size().height;
+
+                            let o1 = pod::object!(
+                                SpaTypes::ObjectParamBuffers,
+                                ParamType::Buffers,
+                                Property::new(
+                                    SPA_PARAM_BUFFERS_buffers,
+                                    pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                ChoiceFlags::empty(),
+                                                ChoiceEnum::Range {
+                                                    default: 16,
+                                                    min: 2,
+                                                    max: 16
+                                                }
+                                    ))),
+                                ),
+                                Property::new(SPA_PARAM_BUFFERS_blocks, pod::Value::Int(plane_count)),
+                                Property::new(
+                                    SPA_PARAM_BUFFERS_dataType,
+                                    pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                ChoiceFlags::empty(),
+                                                ChoiceEnum::Flags {
+                                                    default: 1 << DataType::DmaBuf.as_raw(),
+                                                    flags: vec![1 << DataType::DmaBuf.as_raw()],
+                                                },
+                                    ))),
+                                ),
+                                );

-                            *state = CastState::Ready {
-                                size: format_size,
-                                alpha: format_has_alpha,
-                                extra_negotiation_result: DmaNegotiationResult {
-                                    modifier,
-                                    plane_count: plane_count as i32,
-                                },
-                                damage_tracker: None,
-                            };
+                            // FIXME: Hidden / embedded / metadata cursor
+
+                            let o2 = pod::object!(
+                                SpaTypes::ObjectParamMeta,
+                                ParamType::Meta,
+                                Property::new(
+                                    SPA_PARAM_META_type,
+                                    pod::Value::Id(spa::utils::Id(SPA_META_Header))
+                                ),
+                                Property::new(
+                                    SPA_PARAM_META_size,
+                                    pod::Value::Int(size_of::<spa_meta_header>() as i32)
+                                ),
+                            );
+                            let mut b1 = vec![];
+                            let mut b2 = vec![];
+                            let mut params = [make_pod(&mut b1, o1), make_pod(&mut b2, o2)];

-                            plane_count as i32
+                            if let Err(err) = stream.update_params(&mut params) {
+                                warn!(stream_id, "error updating stream params: {err:?}");
+                                stop_cast();
+                            }
                         }
-                    };
-
-                    // const BPP: u32 = 4;
-                    // let stride = format.size().width * BPP;
-                    // let size = stride * format.size().height;
-
-                    let o1 = pod::object!(
-                        SpaTypes::ObjectParamBuffers,
-                        ParamType::Buffers,
-                        Property::new(
-                            SPA_PARAM_BUFFERS_buffers,
-                            pod::Value::Choice(ChoiceValue::Int(Choice(
-                                ChoiceFlags::empty(),
-                                ChoiceEnum::Range {
-                                    default: 16,
-                                    min: 2,
-                                    max: 16
-                                }
-                            ))),
-                        ),
-                        Property::new(SPA_PARAM_BUFFERS_blocks, pod::Value::Int(plane_count)),
-                        Property::new(
-                            SPA_PARAM_BUFFERS_dataType,
-                            pod::Value::Choice(ChoiceValue::Int(Choice(
-                                ChoiceFlags::empty(),
-                                ChoiceEnum::Flags {
-                                    default: 1 << DataType::DmaBuf.as_raw(),
-                                    flags: vec![1 << DataType::DmaBuf.as_raw()],
-                                },
-                            ))),
-                        ),
-                    );
+                        None => {
+                            warn!(stream_id, "pw stream: modifier prop missing and we don't support shared memory sharing currently");
+                            stop_cast();
+                        }
+                    }

-                    // FIXME: Hidden / embedded / metadata cursor
-
-                    let o2 = pod::object!(
-                        SpaTypes::ObjectParamMeta,
-                        ParamType::Meta,
-                        Property::new(
-                            SPA_PARAM_META_type,
-                            pod::Value::Id(spa::utils::Id(SPA_META_Header))
-                        ),
-                        Property::new(
-                            SPA_PARAM_META_size,
-                            pod::Value::Int(size_of::<spa_meta_header>() as i32)
-                        ),
-                    );
-                    let mut b1 = vec![];
-                    let mut b2 = vec![];
-                    let mut params = [make_pod(&mut b1, o1), make_pod(&mut b2, o2)];

-                    if let Err(err) = stream.update_params(&mut params) {
-                        warn!(stream_id, "error updating stream params: {err:?}");
-                        stop_cast();
-                    }
                 }
             })
             .add_buffer({

From 98100f83048e1f9d3e186f44928fe7b4c1941477 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 00:15:59 +0800
Subject: [PATCH 04/17] pw_utils: change type of `extra_negotiation_result` to
 `Option<DmaNegotiationResult>`

This commit is preparation for supporting shared memory sharing
---
 src/pw_utils.rs | 168 +++++++++++++++++++++++++-----------------------
 1 file changed, 89 insertions(+), 79 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index f2ec1d4df..1ac4062d9 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -119,12 +119,12 @@ enum CastState {
     ConfirmationPending {
         size: Size<u32, Physical>,
         alpha: bool,
-        extra_negotiation_result: DmaNegotiationResult,
+        extra_negotiation_result: Option<DmaNegotiationResult>,
     },
     Ready {
         size: Size<u32, Physical>,
         alpha: bool,
-        extra_negotiation_result: DmaNegotiationResult,
+        extra_negotiation_result: Option<DmaNegotiationResult>,
         // Lazily-initialized to keep the initialization to a single place.
         damage_tracker: Option<OutputDamageTracker>,
     },
@@ -430,10 +430,10 @@ impl PipeWire {
                                 *state = CastState::ConfirmationPending {
                                     size: format_size,
                                     alpha: format_has_alpha,
-                                    extra_negotiation_result: DmaNegotiationResult {
+                                    extra_negotiation_result: Some(DmaNegotiationResult {
                                         modifier,
                                         plane_count: plane_count as i32,
-                                    },
+                                    }),
                                 };

                                 let fixated_format = FormatSet::from_iter([Format {
@@ -479,8 +479,10 @@ impl PipeWire {
                                     extra_negotiation_result,
                                     ..
                                 } if *alpha == format_has_alpha
-                                && extra_negotiation_result.modifier
-                                    == Modifier::from(format.modifier()) =>
+                                && matches!(
+                                    extra_negotiation_result,
+                                    Some(x) if x.modifier == Modifier::from(format.modifier())
+                                )  =>
                                 {
                                     let size = *size;
                                     let alpha = *alpha;
@@ -502,7 +504,8 @@ impl PipeWire {
                                         damage_tracker,
                                     };

-                                    extra_negotiation_result.plane_count
+                                    // Due to matches! guard this unwrap is safe
+                                    extra_negotiation_result.unwrap().plane_count
                                 }
                                 _ => {
                                     // We're negotiating a single modifier, or alpha or modifier changed,
@@ -531,10 +534,10 @@ impl PipeWire {
                                     *state = CastState::Ready {
                                         size: format_size,
                                         alpha: format_has_alpha,
-                                        extra_negotiation_result: DmaNegotiationResult {
+                                        extra_negotiation_result: Some(DmaNegotiationResult {
                                             modifier,
                                             plane_count: plane_count as i32,
-                                        },
+                                        }),
                                         damage_tracker: None,
                                     };

@@ -611,82 +614,89 @@ impl PipeWire {
                 move |stream, (), buffer| {
                     let mut inner = inner.borrow_mut();

-                    let (size, alpha, modifier) = if let CastState::Ready {
-                        size,
-                        alpha,
-                        extra_negotiation_result,
-                        ..
-                    } = &inner.state
-                    {
-                        (*size, *alpha, extra_negotiation_result.modifier)
-                    } else {
-                        trace!(stream_id, "pw stream: add buffer, but not ready yet");
-                        return;
-                    };
+                    match inner.state {
+                        CastState::Ready {
+                            size,
+                            alpha,
+                            extra_negotiation_result,
+                            ..
+                        } => {
+                            match extra_negotiation_result {
+                                Some(DmaNegotiationResult { modifier, .. }) => {
+                                    trace!(
+                                        stream_id,
+                                        "pw stream: add_buffer, size={size:?}, alpha={alpha}, \
+                                        modifier={modifier:?}"
+                                    );

-                    trace!(
-                        stream_id,
-                        "pw stream: add_buffer, size={size:?}, alpha={alpha}, \
-                         modifier={modifier:?}"
-                    );
+                                    unsafe {
+                                        let spa_buffer = (*buffer).buffer;

-                    unsafe {
-                        let spa_buffer = (*buffer).buffer;
+                                        let fourcc = if alpha {
+                                            Fourcc::Argb8888
+                                        } else {
+                                            Fourcc::Xrgb8888
+                                        };

-                        let fourcc = if alpha {
-                            Fourcc::Argb8888
-                        } else {
-                            Fourcc::Xrgb8888
-                        };
+                                        let dmabuf = match allocate_dmabuf(&gbm, size, fourcc, modifier) {
+                                            Ok(dmabuf) => dmabuf,
+                                            Err(err) => {
+                                                warn!(stream_id, "error allocating dmabuf: {err:?}");
+                                                stop_cast();
+                                                return;
+                                            }
+                                        };

-                        let dmabuf = match allocate_dmabuf(&gbm, size, fourcc, modifier) {
-                            Ok(dmabuf) => dmabuf,
-                            Err(err) => {
-                                warn!(stream_id, "error allocating dmabuf: {err:?}");
-                                stop_cast();
-                                return;
-                            }
-                        };
-
-                        let plane_count = dmabuf.num_planes();
-                        assert_eq!((*spa_buffer).n_datas as usize, plane_count);
-
-                        for (i, (fd, (stride, offset))) in
-                            zip(dmabuf.handles(), zip(dmabuf.strides(), dmabuf.offsets()))
-                                .enumerate()
-                        {
-                            let spa_data = (*spa_buffer).datas.add(i);
-                            assert!((*spa_data).type_ & (1 << DataType::DmaBuf.as_raw()) > 0);
-
-                            (*spa_data).type_ = DataType::DmaBuf.as_raw();
-
-                            // With DMA-BUFs, consumers should ignore the maxsize field, and
-                            // producers are allowed to set it to 0.
-                            //
-                            // https://docs.pipewire.org/page_dma_buf.html
-                            (*spa_data).maxsize = 1;
-                            (*spa_data).fd = fd.as_raw_fd() as i64;
-                            (*spa_data).flags = SPA_DATA_FLAG_READWRITE;
-
-                            let chunk = (*spa_data).chunk;
-                            (*chunk).stride = stride as i32;
-                            (*chunk).offset = offset;
-
-                            trace!(
-                                stream_id,
-                                "pw buffer plane: fd={}, stride={stride}, offset={offset}",
-                                (*spa_data).fd
-                            );
-                        }
+                                        let plane_count = dmabuf.num_planes();
+                                        assert_eq!((*spa_buffer).n_datas as usize, plane_count);
+
+                                        for (i, (fd, (stride, offset))) in
+                                            zip(dmabuf.handles(), zip(dmabuf.strides(), dmabuf.offsets()))
+                                                .enumerate()
+                                        {
+                                            let spa_data = (*spa_buffer).datas.add(i);
+                                            assert!((*spa_data).type_ & (1 << DataType::DmaBuf.as_raw()) > 0);
+
+                                            (*spa_data).type_ = DataType::DmaBuf.as_raw();
+
+                                            // With DMA-BUFs, consumers should ignore the maxsize field, and
+                                            // producers are allowed to set it to 0.
+                                            //
+                                            // https://docs.pipewire.org/page_dma_buf.html
+                                            (*spa_data).maxsize = 1;
+                                            (*spa_data).fd = fd.as_raw_fd() as i64;
+                                            (*spa_data).flags = SPA_DATA_FLAG_READWRITE;
+
+                                            let chunk = (*spa_data).chunk;
+                                            (*chunk).stride = stride as i32;
+                                            (*chunk).offset = offset;
+
+                                            trace!(
+                                                stream_id,
+                                                "pw buffer plane: fd={}, stride={stride}, offset={offset}",
+                                                (*spa_data).fd
+                                            );
+                                        }

-                        let fd = (*(*spa_buffer).datas).fd;
-                        assert!(inner.dmabufs.insert(fd, dmabuf).is_none());
-                    }
+                                        let fd = (*(*spa_buffer).datas).fd;
+                                        assert!(inner.dmabufs.insert(fd, dmabuf).is_none());
+                                    }
+
+                                    // During size re-negotiation, the stream sometimes just keeps running, in
+                                    // which case we may need to force a redraw once we got a newly sized buffer.
+                                    if inner.dmabufs.len() == 1 && stream.state() == StreamState::Streaming {
+                                        redraw_();
+                                    }

-                    // During size re-negotiation, the stream sometimes just keeps running, in
-                    // which case we may need to force a redraw once we got a newly sized buffer.
-                    if inner.dmabufs.len() == 1 && stream.state() == StreamState::Streaming {
-                        redraw_();
+                                }
+                                None => {
+                                    warn!("pw stream: shared memory sharing hasn't been implemented")
+                                }
+                            }
+                        }
+                        _ => {
+                            trace!(stream_id, "pw stream: add buffer, but not ready yet");
+                        }
                     }
                 }
             })

From f45caedafc7c9eb7dc945b7e9419585477d27909 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 00:24:23 +0800
Subject: [PATCH 05/17] pw_utils: add some comments about
 `extra_negotiation_result`

---
 src/pw_utils.rs | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 1ac4062d9..d4420a2af 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -113,6 +113,8 @@ struct DmaNegotiationResult {
 #[allow(clippy::large_enum_variant)]
 #[derive(Debug)]
 enum CastState {
+    // extra_negotiation_result = Some(_) means DMA sharing
+    // extra_negotiation_result = None    means SHM sharing
     ResizePending {
         pending_size: Size<u32, Physical>,
     },

From 1c18e6e029f1a1bbd161148a3347263c162c3738 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 02:14:17 +0800
Subject: [PATCH 06/17] pw_utils: support sending SHM sharing as fallback when
 first negotiating

---
 src/pw_utils.rs | 286 +++++++++++++++++++++++++++---------------------
 1 file changed, 161 insertions(+), 125 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index d4420a2af..06b72832c 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -33,7 +33,7 @@ use pipewire::sys::{pw_buffer, pw_stream_queue_buffer};
 use smithay::backend::allocator::dmabuf::{AsDmabuf, Dmabuf};
 use smithay::backend::allocator::format::FormatSet;
 use smithay::backend::allocator::gbm::{GbmBuffer, GbmBufferFlags, GbmDevice};
-use smithay::backend::allocator::{Format, Fourcc};
+use smithay::backend::allocator::{Fourcc};
 use smithay::backend::drm::DrmDeviceFd;
 use smithay::backend::renderer::damage::OutputDamageTracker;
 use smithay::backend::renderer::element::RenderElement;
@@ -138,24 +138,150 @@ pub enum CastSizeChange {
     Pending,
 }

-macro_rules! make_params {
-    ($params:ident, $formats:expr, $size:expr, $refresh:expr, $alpha:expr) => {
-        let mut b1 = Vec::new();
-        let mut b2 = Vec::new();
-
-        let o1 = make_video_params($formats, $size, $refresh, false);
-        let pod1 = make_pod(&mut b1, o1);
-
-        let mut p1;
-        let mut p2;
-        $params = if $alpha {
-            let o2 = make_video_params($formats, $size, $refresh, true);
-            p2 = [pod1, make_pod(&mut b2, o2)];
-            &mut p2[..]
+
+fn make_video_params(
+    video_formats: &Vec<VideoFormat>,
+    modifiers: &Vec<Modifier>,
+    size: Size<u32, Physical>,
+    refresh: u32,
+    fixated: bool,
+) -> pod::Object {
+    let modifier_property = if modifiers.len() == 0 {
+        None
+    } else {
+        let dont_fixate = if (!fixated) && modifiers.len() == 1 && modifiers[0] == Modifier::Invalid
+        {
+            PropertyFlags::DONT_FIXATE
+        } else {
+            PropertyFlags::empty()
+        };
+        let flags = PropertyFlags::MANDATORY | dont_fixate;
+        let modifiers_i64 = modifiers
+            .iter()
+            .map(|m| u64::from(*m) as i64)
+            .collect::<Vec<_>>();
+        Some(Property {
+            key: FormatProperties::VideoModifier.as_raw(),
+            flags,
+            value: pod::Value::Choice(ChoiceValue::Long(Choice(
+                        ChoiceFlags::empty(),
+                        ChoiceEnum::Enum {
+                            default: modifiers_i64[0],
+                            alternatives: modifiers_i64,
+                        },
+            ))),
+        })
+    };
+
+    pipewire::spa::pod::Object {
+        type_: SpaTypes::ObjectParamFormat.as_raw(),
+        id: ParamType::EnumFormat.as_raw(),
+        properties: [
+            vec![
+                pod::property!(FormatProperties::MediaType, Id, MediaType::Video),
+                pod::property!(FormatProperties::MediaSubtype, Id, MediaSubtype::Raw),
+            ],
+            video_formats
+                .iter()
+                .map(|video_format| pod::property!(FormatProperties::VideoFormat, Id, video_format))
+                .collect(),
+                match modifier_property {
+                    Some(prop) => vec![prop],
+                    None => vec![],
+                },
+                vec![
+                    pod::property!(
+                        FormatProperties::VideoSize,
+                        Rectangle,
+                        Rectangle {
+                            width: size.w,
+                            height: size.h,
+        }
+                    ),
+                    pod::property!(
+                        FormatProperties::VideoFramerate,
+                        Fraction,
+                        Fraction { num: 0, denom: 1 }
+                    ),
+                    pod::property!(
+                        FormatProperties::VideoMaxFramerate,
+                        Choice,
+                        Range,
+                        Fraction,
+                        Fraction {
+                            num: refresh,
+                            denom: 1000
+                        },
+                        Fraction { num: 1, denom: 1 },
+                        Fraction {
+                            num: refresh,
+                            denom: 1000
+        }
+                    ),
+                    ],
+                    ]
+                        .concat(),
+    }
+}
+
+fn make_video_params_for_initial_negotiation(
+    possible_modifiers: &FormatSet,
+    size: Size<u32, Physical>,
+    refresh: u32,
+    alpha: bool,
+) -> Vec<pod::Object> {
+    let f = |alpha_| {
+        let video_formats = if alpha_ {
+            vec![VideoFormat::BGRA]
+        } else {
+            vec![VideoFormat::BGRx]
+        };
+
+        let fourcc = if alpha_ {
+            Fourcc::Argb8888
         } else {
-            p1 = [pod1];
-            &mut p1[..]
+            Fourcc::Xrgb8888
         };
+
+        let modifiers: Vec<_> = possible_modifiers
+            .iter()
+            .filter_map(|f| (f.code == fourcc).then_some(f.modifier))
+            .collect();
+
+        trace!("offering: {modifiers:?}");
+
+        if modifiers.len() == 0 {
+            vec![make_video_params(
+                &video_formats,
+                &vec![],
+                size,
+                refresh,
+                false,
+            )]
+        } else {
+            vec![
+                make_video_params(&video_formats, &modifiers, size, refresh, false),
+                make_video_params(&video_formats, &vec![], size, refresh, false),
+            ]
+        }
+    };
+    let pod_objects = if alpha {
+        [f(true), f(false)].concat()
+    } else {
+        f(false)
+    };
+    pod_objects
+}
+
+macro_rules! make_video_params_for_initial_negotiation_macro {
+    ($params:ident, $formats:expr, $size:expr, $refresh:expr, $alpha:expr) => {
+        let $params = make_video_params_for_initial_negotiation($formats, $size, $refresh, $alpha);
+        let mut obj_with_buffer: Vec<(&pod::Object, Vec<u8>)> =
+            $params.iter().map(|obj| (obj, Vec::new())).collect();
+        let $params: Vec<_> = obj_with_buffer
+            .iter_mut()
+            .map(|(obj, buf)| make_pod(buf, (*obj).clone()))
+            .collect();
     };
 }

@@ -438,31 +564,23 @@ impl PipeWire {
                                     }),
                                 };

-                                let fixated_format = FormatSet::from_iter([Format {
-                                    code: fourcc,
-                                    modifier,
-                                }]);
-
-                                let mut b1 = Vec::new();
-                                let mut b2 = Vec::new();
-
-                                let o1 = make_video_params(
-                                    &fixated_format,
-                                    format_size,
-                                    inner.refresh,
-                                    format_has_alpha,
-                                );
-                                let pod1 = make_pod(&mut b1, o1);
+                                let o = make_video_params(&vec![format.format()], &vec![modifier], format_size, refresh, true);
+                                let mut b = Vec::new();
+                                let pod = make_pod(&mut b, o);
+                                let params_1 = vec![pod];

-                                let o2 = make_video_params(
+                                make_video_params_for_initial_negotiation_macro!(
+                                    params_2,
                                     &formats,
                                     format_size,
-                                    inner.refresh,
-                                    format_has_alpha,
+                                    refresh,
+                                    format_has_alpha
                                 );
-                                let mut params = [pod1, make_pod(&mut b2, o2)];

-                                if let Err(err) = stream.update_params(&mut params) {
+
+                                let params = [params_1, params_2].concat();
+
+                                if let Err(err) = stream.update_params(params.clone().as_mut_slice()) {
                                     warn!(stream_id, "error updating stream params: {err:?}");
                                     stop_cast();
                                 }
@@ -730,14 +848,13 @@ impl PipeWire {
             "starting pw stream with size={pending_size:?}, refresh={refresh:?}"
         );

-        let params;
-        make_params!(params, &formats, pending_size, refresh, alpha);
+        make_video_params_for_initial_negotiation_macro!(params, &formats, pending_size, refresh, alpha);
         stream
             .connect(
                 Direction::Output,
                 None,
                 StreamFlags::DRIVER | StreamFlags::ALLOC_BUFFERS,
-                params,
+                params.clone().as_mut_slice(),
             )
             .context("error connecting stream")?;

@@ -788,8 +905,7 @@ impl Cast {
             pending_size: new_size,
         };

-        let params;
-        make_params!(
+        make_video_params_for_initial_negotiation_macro!(
             params,
             &self.formats,
             new_size,
@@ -797,7 +913,7 @@ impl Cast {
             self.offer_alpha
         );
         self.stream
-            .update_params(params)
+            .update_params(params.clone().as_mut_slice())
             .context("error updating stream params")?;

         Ok(CastSizeChange::Pending)
@@ -815,10 +931,9 @@ impl Cast {
         inner.refresh = refresh;

         let size = inner.state.expected_format_size();
-        let params;
-        make_params!(params, &self.formats, size, refresh, self.offer_alpha);
+        make_video_params_for_initial_negotiation_macro!(params, &self.formats, size, refresh, self.offer_alpha);
         self.stream
-            .update_params(params)
+            .update_params(params.clone().as_mut_slice())
             .context("error updating stream params")?;

         Ok(())
@@ -1113,85 +1228,6 @@ impl CastState {
     }
 }

-fn make_video_params(
-    formats: &FormatSet,
-    size: Size<u32, Physical>,
-    refresh: u32,
-    alpha: bool,
-) -> pod::Object {
-    let format = if alpha {
-        VideoFormat::BGRA
-    } else {
-        VideoFormat::BGRx
-    };
-
-    let fourcc = if alpha {
-        Fourcc::Argb8888
-    } else {
-        Fourcc::Xrgb8888
-    };
-
-    let formats: Vec<_> = formats
-        .iter()
-        .filter_map(|f| (f.code == fourcc).then_some(u64::from(f.modifier) as i64))
-        .collect();
-
-    trace!("offering: {formats:?}");
-
-    let dont_fixate = if formats.len() > 1 {
-        PropertyFlags::DONT_FIXATE
-    } else {
-        PropertyFlags::empty()
-    };
-
-    pod::object!(
-        SpaTypes::ObjectParamFormat,
-        ParamType::EnumFormat,
-        pod::property!(FormatProperties::MediaType, Id, MediaType::Video),
-        pod::property!(FormatProperties::MediaSubtype, Id, MediaSubtype::Raw),
-        pod::property!(FormatProperties::VideoFormat, Id, format),
-        Property {
-            key: FormatProperties::VideoModifier.as_raw(),
-            flags: PropertyFlags::MANDATORY | dont_fixate,
-            value: pod::Value::Choice(ChoiceValue::Long(Choice(
-                ChoiceFlags::empty(),
-                ChoiceEnum::Enum {
-                    default: formats[0],
-                    alternatives: formats,
-                }
-            )))
-        },
-        pod::property!(
-            FormatProperties::VideoSize,
-            Rectangle,
-            Rectangle {
-                width: size.w,
-                height: size.h,
-            }
-        ),
-        pod::property!(
-            FormatProperties::VideoFramerate,
-            Fraction,
-            Fraction { num: 0, denom: 1 }
-        ),
-        pod::property!(
-            FormatProperties::VideoMaxFramerate,
-            Choice,
-            Range,
-            Fraction,
-            Fraction {
-                num: refresh,
-                denom: 1000
-            },
-            Fraction { num: 1, denom: 1 },
-            Fraction {
-                num: refresh,
-                denom: 1000
-            }
-        ),
-    )
-}
-
 fn make_pod(buffer: &mut Vec<u8>, object: pod::Object) -> &Pod {
     PodSerializer::serialize(Cursor::new(&mut *buffer), &pod::Value::Object(object)).unwrap();
     Pod::from_bytes(buffer).unwrap()

From 3d70acc67caacf4cb35f5607444e45e38a554205 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 02:54:38 +0800
Subject: [PATCH 07/17] pw_utils: support negotiating to SHM sharing after
 connect

---
 src/pw_utils.rs | 244 ++++++++++++++++++++++++++++--------------------
 1 file changed, 142 insertions(+), 102 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 06b72832c..c8ff64203 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -53,6 +53,7 @@ use crate::utils::get_monotonic_time;

 // Give a 0.1 ms allowance for presentation time errors.
 const CAST_DELAY_ALLOWANCE: Duration = Duration::from_micros(100);
+const SHM_BLOCKS: usize = 1;

 pub struct PipeWire {
     _context: Context,
@@ -509,8 +510,10 @@ impl PipeWire {
                     //    TODO: set CastState to Ready and set buffer to SHM.

                     let object = pod.as_object().unwrap();
+                    let maybe_prop_modifier = object.find_prop(spa::utils::Id(FormatProperties::VideoModifier.0));

-                    match object.find_prop(spa::utils::Id(FormatProperties::VideoModifier.0)) {
+
+                    match maybe_prop_modifier {
                         Some(prop_modifier)
                             if prop_modifier.flags().contains(PodPropFlags::DONT_FIXATE) => {

@@ -585,117 +588,160 @@ impl PipeWire {
                                     stop_cast();
                                 }
                             }
-                        Some(_) => {
-                            // Verify that alpha and modifier didn't change.
-                            let plane_count = match &*state {
-                                CastState::ConfirmationPending {
-                                    size,
-                                    alpha,
-                                    extra_negotiation_result,
-                                }
-                                | CastState::Ready {
-                                    size,
-                                    alpha,
-                                    extra_negotiation_result,
-                                    ..
-                                } if *alpha == format_has_alpha
-                                && matches!(
-                                    extra_negotiation_result,
-                                    Some(x) if x.modifier == Modifier::from(format.modifier())
-                                )  =>
-                                {
-                                    let size = *size;
-                                    let alpha = *alpha;
-                                    let extra_negotiation_result = *extra_negotiation_result;
-
-                                    let damage_tracker =
-                                        if let CastState::Ready { damage_tracker, .. } = &mut *state {
-                                            damage_tracker.take()
-                                        } else {
-                                            None
-                                        };
-
-                                    debug!(stream_id, "pw stream: moving to ready state");
+                        _ => {
+                            let o1 = match maybe_prop_modifier {
+                                Some(_) => {
+                                    // Verify that alpha and modifier didn't change.
+                                    let plane_count = match &*state {
+                                        CastState::ConfirmationPending {
+                                            size,
+                                            alpha,
+                                            extra_negotiation_result,
+                                        }
+                                        | CastState::Ready {
+                                            size,
+                                            alpha,
+                                            extra_negotiation_result,
+                                            ..
+                                        } if *alpha == format_has_alpha
+                                        && matches!(
+                                            extra_negotiation_result,
+                                            Some(x) if x.modifier == Modifier::from(format.modifier())
+                                        )  =>
+                                            {
+                                                let size = *size;
+                                                let alpha = *alpha;
+                                                let extra_negotiation_result = *extra_negotiation_result;
+
+                                                let damage_tracker =
+                                                    if let CastState::Ready { damage_tracker, .. } = &mut *state {
+                                                        damage_tracker.take()
+                                                    } else {
+                                                        None
+                                                    };
+
+                                                debug!(stream_id, "pw stream: moving to ready state");
+
+                                                *state = CastState::Ready {
+                                                    size,
+                                                    alpha,
+                                                    extra_negotiation_result,
+                                                    damage_tracker,
+                                                };
+
+                                                // Due to matches! guard this unwrap is safe
+                                                extra_negotiation_result.unwrap().plane_count
+                                            }
+                                        _ => {
+                                            // We're negotiating a single modifier, or alpha or modifier changed,
+                                            // so we need to do a test allocation.
+                                            let (modifier, plane_count) = match find_preferred_modifier(
+                                                &gbm,
+                                                format_size,
+                                                fourcc,
+                                                vec![format.modifier() as i64],
+                                            ) {
+                                                Ok(x) => x,
+                                                Err(err) => {
+                                                    warn!(stream_id, "pw stream: test allocation failed: {err:?}");
+                                                    stop_cast();
+                                                    return;
+                                                }
+                                            };

-                                    *state = CastState::Ready {
-                                        size,
-                                        alpha,
-                                        extra_negotiation_result,
-                                        damage_tracker,
-                                    };
+                                            debug!(
+                                                stream_id,
+                                                "pw stream: allocation successful \
+                                                (modifier={modifier:?}, plane_count={plane_count}), \
+                                                moving to ready"
+                                            );

-                                    // Due to matches! guard this unwrap is safe
-                                    extra_negotiation_result.unwrap().plane_count
-                                }
-                                _ => {
-                                    // We're negotiating a single modifier, or alpha or modifier changed,
-                                    // so we need to do a test allocation.
-                                    let (modifier, plane_count) = match find_preferred_modifier(
-                                        &gbm,
-                                        format_size,
-                                        fourcc,
-                                        vec![format.modifier() as i64],
-                                    ) {
-                                        Ok(x) => x,
-                                        Err(err) => {
-                                            warn!(stream_id, "pw stream: test allocation failed: {err:?}");
-                                            stop_cast();
-                                            return;
+                                            *state = CastState::Ready {
+                                                size: format_size,
+                                                alpha: format_has_alpha,
+                                                extra_negotiation_result: Some(DmaNegotiationResult {
+                                                    modifier,
+                                                    plane_count: plane_count as i32,
+                                                }),
+                                                damage_tracker: None,
+                                            };
+
+                                            plane_count as i32
                                         }
                                     };
-
-                                    debug!(
-                                        stream_id,
-                                        "pw stream: allocation successful \
-                                        (modifier={modifier:?}, plane_count={plane_count}), \
-                                        moving to ready"
-                                    );
-
+                                    pod::object!(
+                                        SpaTypes::ObjectParamBuffers,
+                                        ParamType::Buffers,
+                                        Property::new(
+                                            SPA_PARAM_BUFFERS_buffers,
+                                            pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                        ChoiceFlags::empty(),
+                                                        ChoiceEnum::Range {
+                                                            default: 16,
+                                                            min: 2,
+                                                            max: 16
+                                                        }
+                                            ))),
+                                        ),
+                                        Property::new(SPA_PARAM_BUFFERS_blocks, pod::Value::Int(plane_count)),
+                                        Property::new(
+                                            SPA_PARAM_BUFFERS_dataType,
+                                            pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                        ChoiceFlags::empty(),
+                                                        ChoiceEnum::Flags {
+                                                            default: 1 << DataType::DmaBuf.as_raw(),
+                                                            flags: vec![1 << DataType::DmaBuf.as_raw()],
+                                                        },
+                                            ))),
+                                        ),
+                                    )
+                                },
+                                None => {
                                     *state = CastState::Ready {
                                         size: format_size,
                                         alpha: format_has_alpha,
-                                        extra_negotiation_result: Some(DmaNegotiationResult {
-                                            modifier,
-                                            plane_count: plane_count as i32,
-                                        }),
+                                        extra_negotiation_result: None,
                                         damage_tracker: None,
                                     };
+                                    pod::object!(
+                                        SpaTypes::ObjectParamBuffers,
+                                        ParamType::Buffers,
+                                        Property::new(
+                                            SPA_PARAM_BUFFERS_buffers,
+                                            pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                        ChoiceFlags::empty(),
+                                                        ChoiceEnum::Range {
+                                                            default: 16,
+                                                            min: 2,
+                                                            max: 16
+                                                        }
+                                            ))),
+                                        ),
+                                        Property::new(
+                                            SPA_PARAM_BUFFERS_blocks,
+                                            pod::Value::Int(SHM_BLOCKS as i32),
+                                        ),
+                                        Property::new(
+                                            SPA_PARAM_BUFFERS_dataType,
+                                            pod::Value::Choice(ChoiceValue::Int(Choice(
+                                                        ChoiceFlags::empty(),
+                                                        ChoiceEnum::Flags {
+                                                            default: 1 << DataType::MemFd.as_raw(),
+                                                            flags: vec![1 << DataType::MemFd.as_raw()],
+                                                        },
+                                            ))),
+                                        ),
+                                        )

-                                    plane_count as i32
                                 }
+
                             };
+                            let mut b1 = vec![];

                             // const BPP: u32 = 4;
                             // let stride = format.size().width * BPP;
                             // let size = stride * format.size().height;

-                            let o1 = pod::object!(
-                                SpaTypes::ObjectParamBuffers,
-                                ParamType::Buffers,
-                                Property::new(
-                                    SPA_PARAM_BUFFERS_buffers,
-                                    pod::Value::Choice(ChoiceValue::Int(Choice(
-                                                ChoiceFlags::empty(),
-                                                ChoiceEnum::Range {
-                                                    default: 16,
-                                                    min: 2,
-                                                    max: 16
-                                                }
-                                    ))),
-                                ),
-                                Property::new(SPA_PARAM_BUFFERS_blocks, pod::Value::Int(plane_count)),
-                                Property::new(
-                                    SPA_PARAM_BUFFERS_dataType,
-                                    pod::Value::Choice(ChoiceValue::Int(Choice(
-                                                ChoiceFlags::empty(),
-                                                ChoiceEnum::Flags {
-                                                    default: 1 << DataType::DmaBuf.as_raw(),
-                                                    flags: vec![1 << DataType::DmaBuf.as_raw()],
-                                                },
-                                    ))),
-                                ),
-                                );
-
                             // FIXME: Hidden / embedded / metadata cursor

                             let o2 = pod::object!(
@@ -710,8 +756,8 @@ impl PipeWire {
                                     pod::Value::Int(size_of::<spa_meta_header>() as i32)
                                 ),
                             );
-                            let mut b1 = vec![];
                             let mut b2 = vec![];
+
                             let mut params = [make_pod(&mut b1, o1), make_pod(&mut b2, o2)];

                             if let Err(err) = stream.update_params(&mut params) {
@@ -719,13 +765,7 @@ impl PipeWire {
                                 stop_cast();
                             }
                         }
-                        None => {
-                            warn!(stream_id, "pw stream: modifier prop missing and we don't support shared memory sharing currently");
-                            stop_cast();
-                        }
                     }
-
-
                 }
             })
             .add_buffer({

From cac391ca84e68c5a1ac3e86a03de07d1d9ba90f8 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 03:04:27 +0800
Subject: [PATCH 08/17] pw_utils: support add and remove shm buffer

---
 src/pw_utils.rs | 84 ++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 79 insertions(+), 5 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index c8ff64203..b4e808650 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -54,6 +54,8 @@ use crate::utils::get_monotonic_time;
 // Give a 0.1 ms allowance for presentation time errors.
 const CAST_DELAY_ALLOWANCE: Duration = Duration::from_micros(100);
 const SHM_BLOCKS: usize = 1;
+const SHM_BYTES_PER_PIXEL: usize = 4;
+

 pub struct PipeWire {
     _context: Context,
@@ -96,6 +98,7 @@ struct CastInner {
     refresh: u32,
     min_time_between_frames: Duration,
     dmabufs: HashMap<i64, Dmabuf>,
+    shmbufs: HashMap<i64, Shmbuf>,
     /// Buffers dequeued from PipeWire in process of rendering.
     ///
     /// This is an ordered list of buffers that we started rendering to and waiting for the
@@ -379,6 +382,7 @@ impl PipeWire {
             refresh,
             min_time_between_frames: Duration::ZERO,
             dmabufs: HashMap::new(),
+            shmbufs: HashMap::new(),
             rendering_buffers: Vec::new(),
         }));

@@ -785,7 +789,7 @@ impl PipeWire {
                                 Some(DmaNegotiationResult { modifier, .. }) => {
                                     trace!(
                                         stream_id,
-                                        "pw stream: add_buffer, size={size:?}, alpha={alpha}, \
+                                        "pw stream: add_buffer (dma), size={size:?}, alpha={alpha}, \
                                         modifier={modifier:?}"
                                     );

@@ -850,7 +854,32 @@ impl PipeWire {

                                 }
                                 None => {
-                                    warn!("pw stream: shared memory sharing hasn't been implemented")
+                                    trace!("pw stream: add_buffer (shm), size={size:?}, alpha={alpha}");
+                                    unsafe {
+                                        let spa_buffer = (*buffer).buffer;
+
+                                        let shmbuf = match allocate_shmbuf(size) {
+                                            Ok(x) => x,
+                                            Err(err) => {
+                                                warn!("error allocating shmbuf: {err:?}");
+                                                stop_cast();
+                                                return;
+                                            }
+                                        };
+
+                                        assert_eq!((*spa_buffer).n_datas as usize, SHM_BLOCKS);
+
+                                        let spa_data = (*spa_buffer).datas;
+                                        assert!((*spa_data).type_ & (1 << DataType::MemFd.as_raw()) > 0);
+
+                                        (*spa_data).type_ = DataType::MemFd.as_raw();
+                                        (*spa_data).maxsize = shmbuf.size as u32;
+                                        (*spa_data).fd = shmbuf.fd.as_raw_fd() as i64;
+                                        (*spa_data).flags = SPA_DATA_FLAG_READWRITE;
+
+                                        let fd = (*(*spa_buffer).datas).fd;
+                                        assert!(inner.shmbufs.insert(fd, shmbuf).is_none());
+                                    }
                                 }
                             }
                         }
@@ -873,10 +902,21 @@ impl PipeWire {
                     unsafe {
                         let spa_buffer = (*buffer).buffer;
                         let spa_data = (*spa_buffer).datas;
-                        assert!((*spa_buffer).n_datas > 0);

-                        let fd = (*spa_data).fd;
-                        inner.dmabufs.remove(&fd);
+                        if (*spa_data).type_ == DataType::DmaBuf.as_raw() {
+                            trace!("pw stream: remove_buffer (dma)");
+                            assert!((*spa_buffer).n_datas > 0);
+
+                            let fd = (*spa_data).fd;
+                            inner.dmabufs.remove(&fd);
+                        } else if (*spa_data).type_ == DataType::MemFd.as_raw() {
+                            trace!("pw stream: remove_buffer (shm)");
+                            assert_eq!((*spa_buffer).n_datas, SHM_BLOCKS as u32);
+                            let fd = (*spa_data).fd;
+                            inner.shmbufs.remove(&fd);
+                        } else {
+                            warn!("pw stream: remove_buffer (unknown), impossible case happens, {:?}", (*spa_data).type_);
+                        }
                     }
                 }
             })
@@ -1338,6 +1378,40 @@ fn allocate_dmabuf(
     Ok(dmabuf)
 }

+#[derive(Debug, Clone)]
+pub struct Shmbuf {
+    fd: Rc<smithay::reexports::rustix::fd::OwnedFd>,
+    stride: usize,
+    size: usize,
+}
+
+fn allocate_shmbuf(size: Size<u32, Physical>) -> anyhow::Result<Shmbuf> {
+    let (w, h) = (size.w as usize, size.h as usize);
+    let stride = w * SHM_BYTES_PER_PIXEL;
+    let size = stride * h;
+    let fd = smithay::reexports::rustix::fs::memfd_create(
+        "shm_buffer",
+        smithay::reexports::rustix::fs::MemfdFlags::CLOEXEC
+            | smithay::reexports::rustix::fs::MemfdFlags::ALLOW_SEALING,
+    )
+    .context("error creating memfd")?;
+    let _ = smithay::reexports::rustix::fs::ftruncate(&fd, size.try_into().unwrap())
+        .context("error set size of the fd")?;
+    let _ = smithay::reexports::rustix::fs::fcntl_add_seals(
+        &fd,
+        smithay::reexports::rustix::fs::SealFlags::SEAL
+            | smithay::reexports::rustix::fs::SealFlags::SHRINK
+            | smithay::reexports::rustix::fs::SealFlags::GROW,
+    )
+    .context("error sealing the fd")?;
+    Ok(Shmbuf {
+        fd: fd.into(),
+        size,
+        stride,
+    })
+}
+
+
 unsafe fn return_unused_buffer(stream: &Stream, pw_buffer: NonNull<pw_buffer>) {
     // pw_stream_return_buffer() requires too new PipeWire (1.4.0). So, mark as
     // corrupted and queue.

From 5a43922be172c33e0ca7085cbbe85ec4fd40a96b Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 03:11:27 +0800
Subject: [PATCH 09/17] pw_utils: refactor `dequeue_buffer_and_render`

---
 src/pw_utils.rs | 98 +++++++++++++++++++++++++------------------------
 1 file changed, 50 insertions(+), 48 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index b4e808650..229ca87da 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1195,60 +1195,62 @@ impl Cast {
     ) -> bool {
         let mut inner = self.inner.borrow_mut();

-        let CastState::Ready { damage_tracker, .. } = &mut inner.state else {
-            error!("cast must be in Ready state to render");
-            return false;
-        };
-        let damage_tracker = damage_tracker
-            .get_or_insert_with(|| OutputDamageTracker::new(size, scale, Transform::Normal));
-
-        // Size change will drop the damage tracker, but scale change won't, so check it here.
-        let OutputModeSource::Static { scale: t_scale, .. } = damage_tracker.mode() else {
-            unreachable!();
-        };
-        if *t_scale != scale {
-            *damage_tracker = OutputDamageTracker::new(size, scale, Transform::Normal);
-        }
+        if let CastState::Ready { damage_tracker, .. } = &mut inner.state {
+            let damage_tracker = damage_tracker
+                .get_or_insert_with(|| OutputDamageTracker::new(size, scale, Transform::Normal));
+
+            // Size change will drop the damage tracker, but scale change won't, so check it here.
+            let OutputModeSource::Static { scale: t_scale, .. } = damage_tracker.mode() else {
+                unreachable!();
+            };
+            if *t_scale != scale {
+                *damage_tracker = OutputDamageTracker::new(size, scale, Transform::Normal);
+            }

-        let (damage, _states) = damage_tracker.damage_output(1, elements).unwrap();
-        if damage.is_none() {
-            trace!("no damage, skipping frame");
-            return false;
-        }
-        drop(inner);
+            let (damage, _states) = damage_tracker.damage_output(1, elements).unwrap();
+            if damage.is_none() {
+                trace!("no damage, skipping frame");
+                return false;
+            }
+            drop(inner);

-        let Some(pw_buffer) = self.dequeue_available_buffer() else {
-            warn!("no available buffer in pw stream, skipping frame");
-            return false;
-        };
-        let buffer = pw_buffer.as_ptr();
+            let Some(pw_buffer) = self.dequeue_available_buffer() else {
+                warn!("no available buffer in pw stream, skipping frame");
+                return false;
+            };

-        unsafe {
-            let spa_buffer = (*buffer).buffer;
+            let buffer = pw_buffer.as_ptr();

-            let fd = (*(*spa_buffer).datas).fd;
-            let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
-
-            match render_to_dmabuf(
-                renderer,
-                dmabuf,
-                size,
-                scale,
-                Transform::Normal,
-                elements.iter().rev(),
-            ) {
-                Ok(sync_point) => {
-                    mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
-                    trace!("queueing buffer with seq={}", self.sequence_counter);
-                    self.queue_after_sync(pw_buffer, sync_point);
-                    true
-                }
-                Err(err) => {
-                    warn!("error rendering to dmabuf: {err:?}");
-                    return_unused_buffer(&self.stream, pw_buffer);
-                    false
+            unsafe {
+                let spa_buffer = (*buffer).buffer;
+
+                let fd = (*(*spa_buffer).datas).fd;
+                let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
+
+                match render_to_dmabuf(
+                    renderer,
+                    dmabuf,
+                    size,
+                    scale,
+                    Transform::Normal,
+                    elements.iter().rev(),
+                ) {
+                    Ok(sync_point) => {
+                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                        trace!("queueing buffer with seq={}", self.sequence_counter);
+                        self.queue_after_sync(pw_buffer, sync_point);
+                        true
+                    }
+                    Err(err) => {
+                        warn!("error rendering to dmabuf: {err:?}");
+                        return_unused_buffer(&self.stream, pw_buffer);
+                        false
+                    }
                 }
             }
+        } else {
+            error!("cast must be in Ready state to render");
+            false
         }
     }


From 9516d67310070054994431613b56ed67e2720842 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 03:54:05 +0800
Subject: [PATCH 10/17] pw_utils: support render to shm buffer

---
 src/pw_utils.rs | 145 +++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 118 insertions(+), 27 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 229ca87da..61750249e 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1,16 +1,18 @@
 use std::cell::RefCell;
+use std::{mem, ptr};
 use std::collections::HashMap;
 use std::io::Cursor;
 use std::iter::zip;
-use std::mem;
 use std::os::fd::{AsFd, AsRawFd, BorrowedFd};
 use std::ptr::NonNull;
 use std::rc::Rc;
 use std::time::Duration;

+use anyhow::{ensure};
 use anyhow::Context as _;
 use calloop::timer::{TimeoutAction, Timer};
 use calloop::RegistrationToken;
+use smithay::backend::renderer::ExportMem;
 use pipewire::context::Context;
 use pipewire::core::{Core, PW_ID_CORE};
 use pipewire::main_loop::MainLoop;
@@ -42,13 +44,14 @@ use smithay::backend::renderer::sync::SyncPoint;
 use smithay::output::{Output, OutputModeSource};
 use smithay::reexports::calloop::generic::Generic;
 use smithay::reexports::calloop::{Interest, LoopHandle, Mode, PostAction};
+use smithay::reexports::rustix;
 use smithay::reexports::gbm::Modifier;
 use smithay::utils::{Physical, Scale, Size, Transform};
 use zbus::object_server::SignalEmitter;

 use crate::dbus::mutter_screen_cast::{self, CursorMode};
 use crate::niri::{CastTarget, State};
-use crate::render_helpers::{clear_dmabuf, render_to_dmabuf};
+use crate::render_helpers::{clear_dmabuf, render_to_dmabuf, render_and_download};
 use crate::utils::get_monotonic_time;

 // Give a 0.1 ms allowance for presentation time errors.
@@ -1195,10 +1198,18 @@ impl Cast {
     ) -> bool {
         let mut inner = self.inner.borrow_mut();

-        if let CastState::Ready { damage_tracker, .. } = &mut inner.state {
+        if let CastState::Ready {
+            damage_tracker,
+            extra_negotiation_result,
+            alpha,
+            ..
+        } = &mut inner.state {
             let damage_tracker = damage_tracker
                 .get_or_insert_with(|| OutputDamageTracker::new(size, scale, Transform::Normal));

+            let extra_negotiation_result = extra_negotiation_result.clone();
+            let alpha = alpha.clone();
+
             // Size change will drop the damage tracker, but scale change won't, so check it here.
             let OutputModeSource::Static { scale: t_scale, .. } = damage_tracker.mode() else {
                 unreachable!();
@@ -1221,33 +1232,74 @@ impl Cast {

             let buffer = pw_buffer.as_ptr();

-            unsafe {
-                let spa_buffer = (*buffer).buffer;
-
-                let fd = (*(*spa_buffer).datas).fd;
-                let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
-
-                match render_to_dmabuf(
-                    renderer,
-                    dmabuf,
-                    size,
-                    scale,
-                    Transform::Normal,
-                    elements.iter().rev(),
-                ) {
-                    Ok(sync_point) => {
-                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
-                        trace!("queueing buffer with seq={}", self.sequence_counter);
-                        self.queue_after_sync(pw_buffer, sync_point);
-                        true
+            match extra_negotiation_result {
+                Some(_) => {
+                    unsafe {
+                        let spa_buffer = (*buffer).buffer;
+
+                        let fd = (*(*spa_buffer).datas).fd;
+                        let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
+
+                        match render_to_dmabuf(
+                            renderer,
+                            dmabuf,
+                            size,
+                            scale,
+                            Transform::Normal,
+                            elements.iter().rev(),
+                        ) {
+                            Ok(sync_point) => {
+                                mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                                trace!("queueing buffer with seq={}", self.sequence_counter);
+                                self.queue_after_sync(pw_buffer, sync_point);
+                                true
+                            }
+                            Err(err) => {
+                                warn!("error rendering to dmabuf: {err:?}");
+                                return_unused_buffer(&self.stream, pw_buffer);
+                                false
+                            }
+                        }
                     }
-                    Err(err) => {
-                        warn!("error rendering to dmabuf: {err:?}");
-                        return_unused_buffer(&self.stream, pw_buffer);
-                        false
+                },
+                None => {
+                    unsafe {
+                        let spa_buffer = (*buffer).buffer;
+
+                        let fd = (*(*spa_buffer).datas).fd;
+                        let shmbuf = self.inner.borrow().shmbufs[&fd].clone();
+
+                        let fourcc = if alpha {
+                            Fourcc::Argb8888
+                        } else {
+                            Fourcc::Xrgb8888
+                        };
+
+
+                        match render_to_shmbuf(
+                            renderer,
+                            &shmbuf,
+                            size,
+                            scale,
+                            Transform::Normal,
+                            fourcc,
+                            elements,
+                        ) {
+                            Ok(()) => {
+                                mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                                trace!("queueing buffer with seq={}", self.sequence_counter);
+                                true
+                            }
+                            Err(err) => {
+                                warn!("error rendering to shmbuf: {err:?}");
+                                return_unused_buffer(&self.stream, pw_buffer);
+                                false
+                            }
+                        }
                     }
-                }
+                },
             }
+
         } else {
             error!("cast must be in Ready state to render");
             false
@@ -1461,3 +1513,42 @@ unsafe fn find_meta_header(buffer: *mut spa_buffer) -> Option<NonNull<spa_meta_h
     let p = spa_buffer_find_meta_data(buffer, SPA_META_Header, size_of::<spa_meta_header>()).cast();
     NonNull::new(p)
 }
+
+fn render_to_shmbuf(
+    renderer: &mut GlesRenderer,
+    buffer: &Shmbuf,
+    size: Size<i32, Physical>,
+    scale: Scale<f64>,
+    transform: Transform,
+    fourcc: Fourcc,
+    elements: &[impl RenderElement<GlesRenderer>],
+) -> anyhow::Result<()> {
+    let expected_size =
+        size.w as usize * size.h as usize * SHM_BYTES_PER_PIXEL as usize;
+    ensure!(buffer.size == expected_size, "invalid buffer size");
+    let mapping = render_and_download(
+        renderer,
+        size,
+        scale,
+        transform,
+        fourcc,
+        elements.iter().rev(),
+    )?;
+    let bytes = renderer
+        .map_texture(&mapping)
+        .context("error mapping texture")?;
+
+    unsafe {
+        let buf =  rustix::mm::mmap(
+            std::ptr::null_mut(),
+            buffer.size as usize,
+            rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
+            rustix::mm::MapFlags::SHARED,
+            buffer.fd.clone(),
+            0,
+        )?;
+        ptr::copy_nonoverlapping(bytes.as_ptr(), buf.cast(), buffer.size);
+        let _ = rustix::mm::munmap(buf, buffer.size).unwrap();
+    }
+    Ok(())
+}

From 007569d229cf480757d3cc5ab64bd1172afe64ed Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 04:14:39 +0800
Subject: [PATCH 11/17] pw_utils: support clean shm buffer

---
 src/pw_utils.rs | 77 ++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 63 insertions(+), 14 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 61750249e..9f838d9da 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1322,24 +1322,56 @@ impl Cast {
         let buffer = pw_buffer.as_ptr();

         unsafe {
-            let spa_buffer = (*buffer).buffer;
+            if (*(*(*buffer).buffer).datas).type_ == DataType::DmaBuf.as_raw() {
+                let spa_buffer = (*buffer).buffer;
+
+                let fd = (*(*spa_buffer).datas).fd;
+                let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
+
+                match clear_dmabuf(renderer, dmabuf) {
+                    Ok(sync_point) => {
+                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                        trace!("queueing clear buffer with seq={}", self.sequence_counter);
+                        self.queue_after_sync(pw_buffer, sync_point);
+                        true
+                    }
+                    Err(err) => {
+                        warn!("error clearing dmabuf: {err:?}");
+                        return_unused_buffer(&self.stream, pw_buffer);
+                        false
+                    }
+                }
+            } else if (*(*(*buffer).buffer).datas).type_ == DataType::MemFd.as_raw() {
+                let blocks = (*(*buffer).buffer).n_datas;

-            let fd = (*(*spa_buffer).datas).fd;
-            let dmabuf = self.inner.borrow().dmabufs[&fd].clone();
+                if blocks as usize != SHM_BLOCKS {
+                    warn!("expected {SHM_BLOCKS} blocks, got {blocks}");
+                    return false;
+                };

-            match clear_dmabuf(renderer, dmabuf) {
-                Ok(sync_point) => {
-                    mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
-                    trace!("queueing clear buffer with seq={}", self.sequence_counter);
-                    self.queue_after_sync(pw_buffer, sync_point);
-                    true
-                }
-                Err(err) => {
-                    warn!("error clearing dmabuf: {err:?}");
-                    return_unused_buffer(&self.stream, pw_buffer);
-                    false
+                let spa_buffer = (*buffer).buffer;
+
+                let fd = (*(*spa_buffer).datas).fd;
+                let shmbuf = self.inner.borrow().shmbufs[&fd].clone();
+
+                match clear_shmbuf(shmbuf) {
+                    Ok (()) => {
+                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                        trace!("queueing clear buffer with seq={}", self.sequence_counter);
+                        true
+
+                    }
+                    Err(err) => {
+                        warn!("error clearing shmbuf: {err:?}");
+                        return_unused_buffer(&self.stream, pw_buffer);
+                        false
+                    }
                 }
+            } else {
+                warn!("unknown data type in dequeue_buffer_and_clear");
+                false
             }
+
         }
     }
 }
@@ -1552,3 +1584,20 @@ fn render_to_shmbuf(
     }
     Ok(())
 }
+
+fn clear_shmbuf(shmbuf: Shmbuf) -> anyhow::Result<()> {
+    let bytes: Vec<u8> = vec![0u8; shmbuf.size];
+    unsafe {
+        let buf = rustix::mm::mmap(
+                std::ptr::null_mut(),
+                shmbuf.size as usize,
+                rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
+                rustix::mm::MapFlags::SHARED,
+                shmbuf.fd.clone(),
+                0,
+            )?;
+        ptr::copy_nonoverlapping(bytes.as_ptr(), buf.cast(), shmbuf.size);
+        let _ = rustix::mm::munmap(buf, shmbuf.size).unwrap();
+    }
+    Ok(())
+}

From 6c3a704b8d0008e61e45ce680742f4628fe57359 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 05:48:23 +0800
Subject: [PATCH 12/17] pw_utils: change paramater of clear_shmbuf to reference

---
 src/pw_utils.rs | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 9f838d9da..94235bf93 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1354,12 +1354,11 @@ impl Cast {
                 let fd = (*(*spa_buffer).datas).fd;
                 let shmbuf = self.inner.borrow().shmbufs[&fd].clone();

-                match clear_shmbuf(shmbuf) {
+                match clear_shmbuf(&shmbuf) {
                     Ok (()) => {
                         mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
                         true
-
                     }
                     Err(err) => {
                         warn!("error clearing shmbuf: {err:?}");
@@ -1585,7 +1584,7 @@ fn render_to_shmbuf(
     Ok(())
 }

-fn clear_shmbuf(shmbuf: Shmbuf) -> anyhow::Result<()> {
+fn clear_shmbuf(shmbuf: &Shmbuf) -> anyhow::Result<()> {
     let bytes: Vec<u8> = vec![0u8; shmbuf.size];
     unsafe {
         let buf = rustix::mm::mmap(

From 7eaeccd2a5650ba3a509616ff2196ec1e53f3458 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 05:49:35 +0800
Subject: [PATCH 13/17] pw_utils: add `queue_after_sync` to SHM sharing

---
 src/pw_utils.rs | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 94235bf93..d51c42b72 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1288,11 +1288,13 @@ impl Cast {
                             Ok(()) => {
                                 mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
                                 trace!("queueing buffer with seq={}", self.sequence_counter);
+                                self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                                 true
                             }
                             Err(err) => {
                                 warn!("error rendering to shmbuf: {err:?}");
                                 return_unused_buffer(&self.stream, pw_buffer);
+                                self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                                 false
                             }
                         }
@@ -1358,6 +1360,7 @@ impl Cast {
                     Ok (()) => {
                         mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
+                        self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                         true
                     }
                     Err(err) => {

From 4760a7861eeb5c07cdff12088eea7d9eea3ee390 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 05:52:25 +0800
Subject: [PATCH 14/17] pw_utils: rename `mark_buffer_as_good` to
 `mark_buffer_after_render`

I will change semantic of this function in later commit.
---
 src/pw_utils.rs | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index d51c42b72..74eabcda1 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1249,7 +1249,7 @@ impl Cast {
                             elements.iter().rev(),
                         ) {
                             Ok(sync_point) => {
-                                mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
                                 trace!("queueing buffer with seq={}", self.sequence_counter);
                                 self.queue_after_sync(pw_buffer, sync_point);
                                 true
@@ -1286,7 +1286,7 @@ impl Cast {
                             elements,
                         ) {
                             Ok(()) => {
-                                mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
                                 trace!("queueing buffer with seq={}", self.sequence_counter);
                                 self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                                 true
@@ -1332,7 +1332,7 @@ impl Cast {

                 match clear_dmabuf(renderer, dmabuf) {
                     Ok(sync_point) => {
-                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
                         self.queue_after_sync(pw_buffer, sync_point);
                         true
@@ -1358,7 +1358,7 @@ impl Cast {

                 match clear_shmbuf(&shmbuf) {
                     Ok (()) => {
-                        mark_buffer_as_good(pw_buffer, &mut self.sequence_counter);
+                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
                         self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                         true
@@ -1518,7 +1518,7 @@ unsafe fn return_unused_buffer(stream: &Stream, pw_buffer: NonNull<pw_buffer>) {
     pw_stream_queue_buffer(stream.as_raw_ptr(), pw_buffer);
 }

-unsafe fn mark_buffer_as_good(pw_buffer: NonNull<pw_buffer>, sequence: &mut u64) {
+unsafe fn mark_buffer_after_render(pw_buffer: NonNull<pw_buffer>, sequence: &mut u64) {
     let pw_buffer = pw_buffer.as_ptr();
     let spa_buffer = (*pw_buffer).buffer;
     let chunk = (*(*spa_buffer).datas).chunk;

From de8c6b5f7384bb0e00625d2f319d145967dfab36 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 06:05:05 +0800
Subject: [PATCH 15/17] pw_utils: update chunk info after render to shm buffer

---
 src/pw_utils.rs | 45 ++++++++++++++++++++++++++++++---------------
 1 file changed, 30 insertions(+), 15 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 74eabcda1..53e2e24a8 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -1249,7 +1249,7 @@ impl Cast {
                             elements.iter().rev(),
                         ) {
                             Ok(sync_point) => {
-                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
+                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter, SharingBuf::DMA(()));
                                 trace!("queueing buffer with seq={}", self.sequence_counter);
                                 self.queue_after_sync(pw_buffer, sync_point);
                                 true
@@ -1286,7 +1286,7 @@ impl Cast {
                             elements,
                         ) {
                             Ok(()) => {
-                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
+                                mark_buffer_after_render(pw_buffer, &mut self.sequence_counter, SharingBuf::SHM(&shmbuf));
                                 trace!("queueing buffer with seq={}", self.sequence_counter);
                                 self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                                 true
@@ -1332,7 +1332,7 @@ impl Cast {

                 match clear_dmabuf(renderer, dmabuf) {
                     Ok(sync_point) => {
-                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
+                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter, SharingBuf::DMA(()));
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
                         self.queue_after_sync(pw_buffer, sync_point);
                         true
@@ -1358,7 +1358,7 @@ impl Cast {

                 match clear_shmbuf(&shmbuf) {
                     Ok (()) => {
-                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter);
+                        mark_buffer_after_render(pw_buffer, &mut self.sequence_counter, SharingBuf::SHM(&shmbuf));
                         trace!("queueing clear buffer with seq={}", self.sequence_counter);
                         self.queue_after_sync(pw_buffer, SyncPoint::signaled());
                         true
@@ -1473,6 +1473,11 @@ pub struct Shmbuf {
     size: usize,
 }

+enum SharingBuf<'a> {
+    DMA (()),
+    SHM (&'a Shmbuf),
+}
+
 fn allocate_shmbuf(size: Size<u32, Physical>) -> anyhow::Result<Shmbuf> {
     let (w, h) = (size.w as usize, size.h as usize);
     let stride = w * SHM_BYTES_PER_PIXEL;
@@ -1518,21 +1523,31 @@ unsafe fn return_unused_buffer(stream: &Stream, pw_buffer: NonNull<pw_buffer>) {
     pw_stream_queue_buffer(stream.as_raw_ptr(), pw_buffer);
 }

-unsafe fn mark_buffer_after_render(pw_buffer: NonNull<pw_buffer>, sequence: &mut u64) {
+unsafe fn mark_buffer_after_render(pw_buffer: NonNull<pw_buffer>, sequence: &mut u64, buf: SharingBuf) {
     let pw_buffer = pw_buffer.as_ptr();
     let spa_buffer = (*pw_buffer).buffer;
     let chunk = (*(*spa_buffer).datas).chunk;

-    // With DMA-BUFs, consumers should ignore the size field, and producers are allowed
-    // to set it to 0.
-    //
-    // https://docs.pipewire.org/page_dma_buf.html
-    //
-    // However, OBS checks for size != 0 as a workaround for old compositor versions,
-    // so we set it to 1.
-    (*chunk).size = 1;
-    // Clear the corrupted flag we may have set before.
-    (*chunk).flags = SPA_CHUNK_FLAG_NONE as i32;
+    match buf {
+        SharingBuf::DMA(_) => {
+            // With DMA-BUFs, consumers should ignore the size field, and producers are allowed
+            // to set it to 0.
+            //
+            // https://docs.pipewire.org/page_dma_buf.html
+            //
+            // However, OBS checks for size != 0 as a workaround for old compositor versions,
+            // so we set it to 1.
+            (*chunk).size = 1;
+            // Clear the corrupted flag we may have set before.
+            (*chunk).flags = SPA_CHUNK_FLAG_NONE as i32;
+        }
+        SharingBuf::SHM(shmbuf) => {
+            (*chunk).size = 1;
+            (*chunk).stride = shmbuf.stride as i32;
+            (*chunk).offset = 0;
+        }
+    }
+

     *sequence = sequence.wrapping_add(1);
     if let Some(header) = find_meta_header(spa_buffer) {

From 4fbf036c8df88a5b0a0cb2b2672d47957addef01 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 06:17:00 +0800
Subject: [PATCH 16/17] pw_utils: avoid excessive imports

---
 src/pw_utils.rs | 38 +++++++++++++++++++-------------------
 1 file changed, 19 insertions(+), 19 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 53e2e24a8..33fd041a3 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -180,7 +180,7 @@ fn make_video_params(
         })
     };

-    pipewire::spa::pod::Object {
+    pod::Object {
         type_: SpaTypes::ObjectParamFormat.as_raw(),
         id: ParamType::EnumFormat.as_raw(),
         properties: [
@@ -1468,7 +1468,7 @@ fn allocate_dmabuf(

 #[derive(Debug, Clone)]
 pub struct Shmbuf {
-    fd: Rc<smithay::reexports::rustix::fd::OwnedFd>,
+    fd: Rc<rustix::fd::OwnedFd>,
     stride: usize,
     size: usize,
 }
@@ -1482,21 +1482,21 @@ fn allocate_shmbuf(size: Size<u32, Physical>) -> anyhow::Result<Shmbuf> {
     let (w, h) = (size.w as usize, size.h as usize);
     let stride = w * SHM_BYTES_PER_PIXEL;
     let size = stride * h;
-    let fd = smithay::reexports::rustix::fs::memfd_create(
+    let fd = rustix::fs::memfd_create(
         "shm_buffer",
-        smithay::reexports::rustix::fs::MemfdFlags::CLOEXEC
-            | smithay::reexports::rustix::fs::MemfdFlags::ALLOW_SEALING,
+        rustix::fs::MemfdFlags::CLOEXEC
+        | rustix::fs::MemfdFlags::ALLOW_SEALING,
     )
-    .context("error creating memfd")?;
-    let _ = smithay::reexports::rustix::fs::ftruncate(&fd, size.try_into().unwrap())
+        .context("error creating memfd")?;
+    let _ = rustix::fs::ftruncate(&fd, size.try_into().unwrap())
         .context("error set size of the fd")?;
-    let _ = smithay::reexports::rustix::fs::fcntl_add_seals(
+    let _ = rustix::fs::fcntl_add_seals(
         &fd,
-        smithay::reexports::rustix::fs::SealFlags::SEAL
-            | smithay::reexports::rustix::fs::SealFlags::SHRINK
-            | smithay::reexports::rustix::fs::SealFlags::GROW,
+        rustix::fs::SealFlags::SEAL
+        | rustix::fs::SealFlags::SHRINK
+        | rustix::fs::SealFlags::GROW,
     )
-    .context("error sealing the fd")?;
+        .context("error sealing the fd")?;
     Ok(Shmbuf {
         fd: fd.into(),
         size,
@@ -1606,13 +1606,13 @@ fn clear_shmbuf(shmbuf: &Shmbuf) -> anyhow::Result<()> {
     let bytes: Vec<u8> = vec![0u8; shmbuf.size];
     unsafe {
         let buf = rustix::mm::mmap(
-                std::ptr::null_mut(),
-                shmbuf.size as usize,
-                rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
-                rustix::mm::MapFlags::SHARED,
-                shmbuf.fd.clone(),
-                0,
-            )?;
+            std::ptr::null_mut(),
+            shmbuf.size as usize,
+            rustix::mm::ProtFlags::READ | rustix::mm::ProtFlags::WRITE,
+            rustix::mm::MapFlags::SHARED,
+            shmbuf.fd.clone(),
+            0,
+        )?;
         ptr::copy_nonoverlapping(bytes.as_ptr(), buf.cast(), shmbuf.size);
         let _ = rustix::mm::munmap(buf, shmbuf.size).unwrap();
     }

From 846346aa888a2f75587d06d4c0a3d6212a0876b2 Mon Sep 17 00:00:00 2001
From: wrvsrx <wrvsrx@outlook.com>
Date: Tue, 2 Sep 2025 06:18:36 +0800
Subject: [PATCH 17/17] pw_utils: clean a variable name

---
 src/pw_utils.rs | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/pw_utils.rs b/src/pw_utils.rs
index 33fd041a3..949bd9ef3 100644
--- a/src/pw_utils.rs
+++ b/src/pw_utils.rs
@@ -237,14 +237,14 @@ fn make_video_params_for_initial_negotiation(
     refresh: u32,
     alpha: bool,
 ) -> Vec<pod::Object> {
-    let f = |alpha_| {
-        let video_formats = if alpha_ {
+    let f = |alpha| {
+        let video_formats = if alpha {
             vec![VideoFormat::BGRA]
         } else {
             vec![VideoFormat::BGRx]
         };

-        let fourcc = if alpha_ {
+        let fourcc = if alpha {
             Fourcc::Argb8888
         } else {
             Fourcc::Xrgb8888
